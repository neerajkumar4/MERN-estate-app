{"ast":null,"code":"export class Schema {\n  constructor(schema) {\n    this.spec = schema;\n  }\n  getFieldType(fieldName) {\n    var _a;\n    return (_a = this.spec) === null || _a === void 0 ? void 0 : _a[fieldName];\n  }\n  getKeys() {\n    return Object.keys(this.spec);\n  }\n  setSchemaOptionsForAllType(data) {\n    if (data === this.data) {\n      return;\n    }\n    Object.entries(this.spec).forEach(([key, type]) => {\n      type.setSchemaOptions(this.spec, data === null || data === void 0 ? void 0 : data[key]);\n    });\n    this.data = data;\n  }\n  checkForField(fieldName, data) {\n    this.setSchemaOptionsForAllType(data);\n    const fieldChecker = this.spec[fieldName];\n    if (!fieldChecker) {\n      // fieldValue can be anything if no schema defined\n      return {\n        hasError: false\n      };\n    }\n    return fieldChecker.check(data[fieldName], data, fieldName);\n  }\n  checkForFieldAsync(fieldName, data) {\n    this.setSchemaOptionsForAllType(data);\n    const fieldChecker = this.spec[fieldName];\n    if (!fieldChecker) {\n      // fieldValue can be anything if no schema defined\n      return Promise.resolve({\n        hasError: false\n      });\n    }\n    return fieldChecker.checkAsync(data[fieldName], data, fieldName);\n  }\n  check(data) {\n    const checkResult = {};\n    Object.keys(this.spec).forEach(key => {\n      if (typeof data === 'object') {\n        checkResult[key] = this.checkForField(key, data);\n      }\n    });\n    return checkResult;\n  }\n  checkAsync(data) {\n    const checkResult = {};\n    const promises = [];\n    const keys = [];\n    Object.keys(this.spec).forEach(key => {\n      keys.push(key);\n      promises.push(this.checkForFieldAsync(key, data));\n    });\n    return Promise.all(promises).then(values => {\n      for (let i = 0; i < values.length; i += 1) {\n        checkResult[keys[i]] = values[i];\n      }\n      return checkResult;\n    });\n  }\n}\nexport function SchemaModel(o) {\n  return new Schema(o);\n}\nSchemaModel.combine = function combine(...specs) {\n  return new Schema(specs.map(model => model.spec).reduce((accumulator, currentValue) => Object.assign(accumulator, currentValue), {}));\n};","map":{"version":3,"names":["Schema","constructor","schema","spec","getFieldType","fieldName","_a","getKeys","Object","keys","setSchemaOptionsForAllType","data","entries","forEach","key","type","setSchemaOptions","checkForField","fieldChecker","hasError","check","checkForFieldAsync","Promise","resolve","checkAsync","checkResult","promises","push","all","then","values","i","length","SchemaModel","o","combine","specs","map","model","reduce","accumulator","currentValue","assign"],"sources":["D:\\MERN estate\\client\\node_modules\\schema-typed\\src\\Schema.ts"],"sourcesContent":["import { SchemaDeclaration, SchemaCheckResult, CheckResult, PlainObject } from './types';\nimport { MixedType } from './MixedType';\n\nexport class Schema<DataType = any, ErrorMsgType = string> {\n  readonly spec: SchemaDeclaration<DataType, ErrorMsgType>;\n  private data: PlainObject;\n\n  constructor(schema: SchemaDeclaration<DataType, ErrorMsgType>) {\n    this.spec = schema;\n  }\n\n  getFieldType<T extends keyof DataType>(fieldName: T) {\n    return this.spec?.[fieldName];\n  }\n\n  getKeys() {\n    return Object.keys(this.spec);\n  }\n\n  setSchemaOptionsForAllType(data: PlainObject) {\n    if (data === this.data) {\n      return;\n    }\n\n    Object.entries(this.spec).forEach(([key, type]) => {\n      (type as MixedType).setSchemaOptions(this.spec as any, data?.[key]);\n    });\n\n    this.data = data;\n  }\n\n  checkForField<T extends keyof DataType>(fieldName: T, data: DataType) {\n    this.setSchemaOptionsForAllType(data);\n\n    const fieldChecker = this.spec[fieldName];\n    if (!fieldChecker) {\n      // fieldValue can be anything if no schema defined\n      return { hasError: false };\n    }\n\n    return fieldChecker.check((data[fieldName] as unknown) as never, data, fieldName as string);\n  }\n\n  checkForFieldAsync<T extends keyof DataType>(\n    fieldName: T,\n    data: DataType\n  ): Promise<CheckResult<ErrorMsgType | string>> {\n    this.setSchemaOptionsForAllType(data);\n\n    const fieldChecker = this.spec[fieldName];\n    if (!fieldChecker) {\n      // fieldValue can be anything if no schema defined\n      return Promise.resolve({ hasError: false });\n    }\n    return fieldChecker.checkAsync(\n      (data[fieldName] as unknown) as never,\n      data,\n      fieldName as string\n    );\n  }\n\n  check<T extends keyof DataType>(data: DataType) {\n    const checkResult: PlainObject = {};\n    Object.keys(this.spec).forEach(key => {\n      if (typeof data === 'object') {\n        checkResult[key] = this.checkForField(key as T, data);\n      }\n    });\n\n    return checkResult as SchemaCheckResult<DataType, ErrorMsgType>;\n  }\n\n  checkAsync<T extends keyof DataType>(data: DataType) {\n    const checkResult: PlainObject = {};\n    const promises: Promise<CheckResult<ErrorMsgType | string>>[] = [];\n    const keys: string[] = [];\n\n    Object.keys(this.spec).forEach((key: string) => {\n      keys.push(key);\n      promises.push(this.checkForFieldAsync(key as T, data));\n    });\n\n    return Promise.all(promises).then(values => {\n      for (let i = 0; i < values.length; i += 1) {\n        checkResult[keys[i]] = values[i];\n      }\n      return checkResult as SchemaCheckResult<DataType, ErrorMsgType>;\n    });\n  }\n}\n\nexport function SchemaModel<DataType = PlainObject, ErrorMsgType = string>(\n  o: SchemaDeclaration<DataType, ErrorMsgType>\n) {\n  return new Schema<DataType, ErrorMsgType>(o);\n}\n\nSchemaModel.combine = function combine<DataType = any, ErrorMsgType = string>(\n  ...specs: Schema<any, ErrorMsgType>[]\n) {\n  return new Schema<DataType, ErrorMsgType>(\n    specs\n      .map(model => model.spec)\n      .reduce((accumulator, currentValue) => Object.assign(accumulator, currentValue), {} as any)\n  );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}